---
title: 保护模式的内存地址机制
date: 2018-06-01 15:03:14
tags: 
- OS
---
## 前言
学汇编的时候我们知道通过引入段地址和偏移地址,可以计算出物理地址.在8086CPU下就能访问到2^20byte内存.但是x86时代的计算机内存更大,而且对安全性要求也高.于是产生了这种机制(举个32位下的例子)–保护模式:

## 笔记
1. 虚拟地址->线性地址
我们在所有应用程序里用的是虚拟地址,在实模式下,段寄存器里存储的就是段地址,但是在保护模式下,段寄存器或者叫段选择器里保存的是段选择子.

全局描述符表(GDT)的线性基地址在GDTR中.
首先读取段选择器里的段选择子的一部分作为索引号在GDT查找,获得这个段的段描述符.当然还有一部分用来做一些权限控制.
从段描述符里找到段基址,与指令中的偏移值组合.得到线性地址.
值得注意的几个点:
GDT的线性基地址在GDTR中,而不是GDT存在GDTR中,GDT是存在内存中的.因此GDT的大小其实可变,不像下面的页表读取完硬件后就设定好了,也不用局限于GDTR的大小.
段描述符是8字节,除了段基址外,还有很多控制位.比如段界限,这个就用来与你的段偏移值进行比较,如果超过了这个界限,那么就是不被允许访问的.

2. 线性地址->物理地址
如果我们没有开启页表,那么线性地址就是物理地址.
那么开启以后,其转换规则则如下:
    1. 首先page directory的物理地址存在CR3这个寄存器里.
    2. 拿线性地址的前10位当序号,在page directory里找该线性地址对应的page table的PPN(physical page number),通过这个PPN找到page table的物理地址.至于如何找,我还不清楚.
    3. 再拿线性地址的第二个10位当序号,在这个对应的page table里找到对应的page table entry(PTE).
    4. 最后把找到的这个PTE的前20位替代掉线性地址的前20位(也就是我们刚才用来找page table entry的那20位),与后面的12位形成真正的物理地址(PA).

也就是类似于我们在8086的段地址不能直接从地址总线里得到,而是要通过一些查表的方式得到.在x86模式下,page directory的大小是2^32 bytes,也就是2^10 个条(entries),也就是有2^10次方个page table.而每一个page table也是2^10个条目.每一个条目决定了物理地址的前20位,也就是还有后12位作为偏移,也就是每一个page table条目指向的是一个2^12bytes的物理内存范围.

## 问题解答
1. 为什么是页表? 为什么不是简单的把地址总线加到31根,或者多设几个段地址,然后加上偏移地址也可以找到相应的PA?
    + 有效控制
    因为引入page table的方式,我们可以对内存进行更有力的控制,从而达到安全性的目的.上面的PTE和page table我们只用到了前面的20位形成PV,而每一个PTE和PD里的条目都是32位的,也就是说还有12位我们可以用来存储一些标志位,比如某一位的值为1则表示应用程序可以访问,又设置某一位的值可以限制该物理地址是可读还是可写,等等.

    + 防止碎片化
    在分段模型下，内存的分配是不定长的，时间长了，内存空间就会碎片化，就有可能出现一种情况：内存空间是有的，但都是小块，无法分配给某个任务。为了解决这个问题，在支持分页功能后，分页功能将物理内存空间划分成逻辑上的页。页的大小是固定的，一般为 4KB，通过使用页，可以简化内存管理。
但是又不能只能有页机制,因为段基址带来的保护模式比较好.

1. 为什么是4kb?
那或者为什么把一个页表大小设置为4KB而不是4MB?为什么要分成两级,而不是简单的把让线性地址的前20位去当作index取找page table?而是前10位找page directory里的page table序号,然后再用中间的10位在某一个page table里找PPN?
页表分成4MB也可以,但是考虑到早期的计算机软件,4MB的内存对许多软件来说都非常的大,但是一个页表顶多能被一个应用程序占有,因此会造成内存浪费.
至于为什么分成两极,对于一个2^20大小的表,要随机查找是非常的耗时的.但是分成两次查找会有效率得多.至于为什么不分成3次,4次查找,当然是时间复杂度和空间复杂度的trade off,4个表要占用的物理内存太大了.
