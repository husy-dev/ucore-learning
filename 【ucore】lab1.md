---
title: 【ucore】lab1
date: 2018-03-24 11:32:06
tags:
- ucore
---

## 实验目标
这里主要是一些计算机系统的一些知识，大部分还和操作系统没什么关系。如果你有些艰难的话，还是先去看看前置课程，比如汇编语言（王爽），大名鼎鼎的CSAPP以及它的网课等等。但是话说回来，这一章有很多细节你如果搞不清楚也不太影响后面对操作系统的实验完成。

## 实验内容
### 练习1：理解通过make生成执行文件的过程。
这个主要是要熟悉makefile的语法，其实质就是一种简单的文本替换。这里的只需要了解到ucore.img是由kernel和bootblock组成的就行。bootblock负责启动与加载kernel，kernel就是真正的操作系统内核
```
UCOREIMG	:= $(call totarget,ucore.img)
$(UCOREIMG): $(kernel) $(bootblock)
	$(V)dd if=/dev/zero of=$@ count=10000
	$(V)dd if=$(bootblock) of=$@ conv=notrun
	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
$(call create_target,ucore.img)
```
### 练习2：使用qemu执行并调试lab1中的软件。
这里是为了熟悉qemu与gdb的搭配使用。如果有认真看[ucore实验环境准备]就会知道，而gdb的操作语法可以[参考](https://www.gnu.org/software/gdb/documentation/)

### 练习3：分析bootloader进入保护模式的过程。
为什么要进入保护模式的原因不多说，随意一本教程都有。主要的[知识点]就是保护模式下的CPU的编址与寻址。
1. 初始化GDT表无非是创建了一个的gdtdesc数据结构，然后用lgdt这个汇编命令将GDT的内存地址放入lgdt寄存器里。这里要注意GDT并没有直接放入寄存器，它和后面讲的TLB（Translation lookasid table）不一样，这个本质上就是一个RAM，因此它就是整个表都放在CPU里。
2. 另一个任务是进入将实模式切换为保护模式，通过将cr0寄存器PE位置1便开启了保护模式。至于后面的跳转只是为了更新cs:ip里的值，因为毕竟此时我们打开了段页式的内存访问机制。因此cs:ip的值要更新一下。

### 练习4：分析bootloader加载ELF格式的OS的过程。
1. bootloader如何读取硬盘扇区的 
我总觉得读一次磁盘只需要一次等待，实际上需要两次。一次等待它能够接收读取命令，发送了要读取的命令以后，再等待一次，开始读取数。

2. bootloader是如何加载ELF格式的OS？
这里涉及到了[链接]的一部分知识。我们至少要知道一个ELF是由一些段（section）组成的，而其ELF存放了很多如何读取这个文件的信息。比如每一个段的相对偏移啊，段的性质。
另一个要注意的kernel.ld文件里的这个，0x100000是作为kernel的绝对加载起始地址，因此ELF加载时重定位都是在这个基础上做偏移。
```C
SECTIONS {
	/* Load the kernel at this address: "." means the current address */
	. = 0x100000;
```
### 练习5：实现函数调用堆栈跟踪函数 （需要编程）
1. 这里的知识点就是考察函数调用栈[^footnote]：
+ ESP：栈指针寄存器(extended stack pointer)，永远指向系统栈最上面一个栈帧的栈顶。**注意如果用push操作，esp指向的是栈里有值的第一个，而不是指向下一个存放点。**
+ EBP：永远指向系统栈最上面一个栈帧的底部。
+ 函数栈帧：ESP和EBP之间的内存空间为当前栈帧，EBP标识了当前栈帧的底部，ESP标识了当前栈帧的顶部。
+ EIP：指向下一条待执行的指令地址。

+ 函数调用大致包括以下几个步骤：
1. 参数入栈：将参数从右向左依次压入系统栈中。
2. 返回地址入栈：也就是call指令执行的，将当前代码区调用指令的下一条指令地址(返回地址)压入栈中，然后把eip指向调用函数的第一条指令。
4. 栈帧调整：包括保存当前栈帧状态值，已备后面恢复本栈帧时使用（EBP入栈）；将当前栈帧切换到新栈帧（将ESP值装入EBP，更新栈帧底部）；给新栈帧分配空间。（把ESP减去所需空间的大小，抬高栈顶）
![函数调用栈][1]
  [1]: http://static.zybuluo.com/Husy/xz35inr8bylhthl5mbofadow/1314ce0c49d0a1e2800e23ca3d5cdd75_r.jpg
 
这里有几个地方是我之前有误解的：
1. 调用函数参数不是一个个push进去的，而是直接让esp-参数大小，使其指向栈的最顶端，然后用movl 参数把栈填满。而使用函数参数也不是我想的那样一个个按顺序pop出来，而是通过ebp寄存器再加上偏移去找，比如ebp+8就是第一个参数（从左往右数，因为入栈的时候是从右往左）。反过来想pop出来只能是放在寄存器，万一参数数量太多，寄存器不够呢？这个限制太致命了，所以不能这么做。
2. 另外说到保存当前函数的栈第一直觉是保存esp，但其实我们保存的是ebp。并没有保存esp。因为我们每次都让esp赋值给ebp，实际上也是保存的esp了。

2. 而着一个地方最最关键的思路就是ebp是循环指向的。如果ebp代表当前寄存器ebp的值，那么*ebp指向的是前一个帧的ebp，于是**ebp指向的就是前前个帧的ebp……这就是一种调用顺序了。

### 练习6：完善中断初始化和处理 （需要编程）
我不太理解ucore为什么要在lab1里就把中断这些细节都过一遍。这样对自学非常不友好。如果你也是自学，我觉得在现阶段你只需要知道整个中断机制的处理逻辑就好，代码细节后面讲了内存管理与进程以后再慢慢来：
1. 中断发生时，硬件和软件互相配合。
2. 获取一个中断码在中断向量表里去找中断服务例程的入口地址。
3. 处理完以后，结果是要么结束当前进程，要么处理好了中断，接着回来执行。
但是，看起来好像这就是一个函数调用，其实其底层并不是。因为这两个处理程序并不是一个进程内的，不像函数调用一样有共享的堆栈。甚至可能是用户态，处理中断时需要进入内核态。因此这里更细节的东西涉及到了进程切换，系统调用等等细节。

## 参考资料
[^footnote]: 更详细的讲解请参考：https://www.zhihu.com/question/22444939  和 https://www.jianshu.com/p/594357dff57e